c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z,a,b,c,t,x0,y0,z0)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
low = -10
high = 10
x = 1.1; y = 1.1, z = 1.1;t=1.1
while( any( c(x,y,z,t)-floor(c(x,y,z,t)) > 0) ){
x0 = sample(low:high,1)
y0 = sample(low:high,1)
z0 = sample(low:high,1)
a = sample(low:high,1)
b = sample(low:high,1)
c = sample(low:high,1)
d = sample(low:high,1)
t = (d - a*x0-b*y0-c*z0)/(a^2+b^2+c^2)
x = x0 + a*t
y = y0 + b*t
z = z0 + b*t
}
c(x,y,z)
c(x0,y0,z0)
t
c(a,b,c,d)
library(swirl)
load("/Users/jbaggett/Google Drive/Gdrive_snap_May_15/MS Data Science/DS 705/Revision Fall 2017 (Includes new class materials)/Class Materials /datasets/farmpond.rda")
require(DS705data)
data("farmpond")
names(farmpond)
names(farmpond)[100] = "RICH"
names(farmpond)
.598-.402
.629-.371
.582-.418
# Final Exam - Problem 7
# Jennifer Salvo
require(gramEvol)
require(GA)
require(GenSA)
# find the minimum value of this function
# on the domain -5 <= x <= 5, -5 <= y <= 5
# you can call the function like this:
# f( c(x,y) ), e.g.
#x1 = c(.5,.5);
#fitness(x1);
#set default values
dimension = 2;
lower = rep(-5,dimension);
upper = rep(5,dimension);
R = qr.Q(qr(matrix(c(1,2,3,4),nrow=2,ncol=2,byrow=T)))
#Trial 1 - genetic algorithm ga with local search
fitness = function(x){
# x should be a vector with two elements e.g. fitness(c(1,2))
z = R%*%x+c(.5,.5);
s = 100*(z[1]^2-z[2])^2 + (z[1]-1)^2;
return((10*(s/4000-cos(s))+10)*-1) #for minimization, need to multiply by -1 for ga function
}
result = ga(type="real-valued",fitness=fitness,min=lower,max=upper,maxiter=10000,popSize=100,optim=TRUE)
round(result@solution,5)
result@fitnessValue
#Trial 2 - simulated annealing GenSA
fitness = function(x){
# x should be a vector with two elements e.g. fitness(c(1,2))
z = R%*%x+c(.5,.5);
s = 100*(z[1]^2-z[2])^2 + (z[1]-1)^2;
return((10*(s/4000-cos(s))+10)) #for minimization, need to multiply by -1 for ga function
}
#First argument (par) - Initial values for the components to be optimized.
#Default is NULL, in which case, default values will be generated automatically.
result = GenSA(NULL,fitness,lower=lower,upper=upper,control=list(max.call=10000))
result$value
result$par
#Trial 3 - optim for local search
fitness = function(x){
# x should be a vector with two elements e.g. fitness(c(1,2))
z = R%*%x+c(.5,.5);
s = 100*(z[1]^2-z[2])^2 + (z[1]-1)^2;
return((10*(s/4000-cos(s))+10)) #for minimization, need to multiply by -1 for ga function
}
bestmin <- 100000;
iteration = 0;
for (j in 1:10000){
x0 <- runif(dimension,min=-5,max=5);
result <- optim(x0,fitness,method="L-BFGS-B",lower=lower,upper=upper)
if (result$value<bestmin){ bestmin = result$value; bestx = result$par; iteration = j;}
}
bestmin
bestx
iteration
?rstudio
?load
.libPaths()
sample(c("H","T"),30,replace=T)
(1-(1/2)^5)^25
(1-(1/2)^4)^26
x = cbind( c(0,2,2,7,7,15,17,19), c(0,0,0,2,2,11,13,11), c(1,1,2,3,6,7,12,7))
x
colMeans(x)
f = 0:7
sum( x[,1]*f)
c = 0:7
sum( x[,1]*c)/69
sum( x[,2]*c)/40
sum( x[,3]*c)/39
69-18
51/69
5/7
rmarkdown::render()
rmarkdown::render()
??render
setwd("~/Google Drive/Gdrive_snap_May_15/MS Data Science/DS 705/Revision Fall 2017 (Includes new class materials)/Class Materials /Weekly Content/Lesson 03/Lesson 3 Homework Packet")
rmarkdown::render("Week_03_HW Submission.Rmd")
rmarkdown::render("Week_03_HW Submission.Rmd","word_document")
#conducting t-test.
t.test(treated,untreated,alternative = "less")
# Don't modify this chunk of code, it is just installing and loading the DS705data package
if (!require(DS705data)){
if (!require(devtools)){
install.packages('devtools',repos="http://cran.rstudio.com")
}
library(devtools)
install_github('DataScienceUWL/DS705data')
}
require(DS705data)
#load in the WormSheep dataset from the DS705data package
data("WormSheep")
#create a boxplot of worms by treatment type.
boxplot(worms~treated, data = WormSheep, main = "Distribution of Worms in Treated vs. Untreated Sheep", xlab = '', ylab = "Number of Worms")
#pull the appropiate data into their own vectors - treated vs. untreated
treated = WormSheep[WormSheep$treated == "treated",1]
untreated = WormSheep[WormSheep$treated == "untreated",1]
#create histograms of the treated and untreated sheep
hist(treated, main = "Distribution of Worms in Treated Sheep", xlab = "Number of Worms")
hist(untreated, main = "Distribution of Worms in Untreated Sheep", xlab = "Number of Worms")
#create QQ plots to assess normality in the samples
qqnorm(treated, main = "Normal Q-Q Plot for Treated Sheep")
qqline(treated)
qqnorm(untreated, main = "Normal Q-Q Plot for Untreated Sheep")
qqline(untreated)
#using the shapiro test to test the normality of the sample for treated sheep.
shapiro.test(treated)
#using the shapiro test to test the normality of the sample for untreated sheep.
shapiro.test(untreated)
#conducting t-test.
t.test(treated,untreated,alternative = "less")
#conducting a t-test for difference in means, testing mu1 - mu2.
t.test(treated,untreated,alternative = "two.sided")
#loading the "delays" dataset from the DS705data package.
data("delays")
#pulling delay times into their own vectors, by airport
omega = delays[delays$airline == "Omega",1]
skybird = delays[delays$airline == "Skybird",1]
#calculating the mean, median and sd for omega
summary(omega)[3:4]
print(paste("Standard Devidation:",sd(omega)))
#calculating the mean, median and sd for skybird
summary(skybird)[3:4]
print(paste("Standard Devidation:",sd(skybird)))
#create a boxplot of delay times by airline.
boxplot(delay~airline, data = delays, main = "Distribution of Delay Times by Airport", xlab = '', ylab = "Delay (in Hours)")
#create histograms of the delay times of omega and skybird
hist(omega, main = "Distribution of Delay Times in Omega Airlines", xlab = "Delay (in Hours)")
hist(skybird, main = "Distribution of Delay Times in Skybird Airlines", xlab = "Delay (in Hours)")
#create QQ plots to assess normality in the samples
qqnorm(omega, main = "Normal Q-Q Plot for Delay Times in Omega Airlines")
qqline(omega)
qqnorm(skybird, main = "Normal Q-Q Plot for Delay Times in Skybird Airlines")
qqline(skybird)
#perform a shapiro test to assess the normality of the omega sample.
shapiro.test(omega)
#perform a shapiro test to assess the normality of the skybird sample.
shapiro.test(skybird)
#create a boxplot of delay times by airline.
boxplot(delay~airline, data = delays, main = "Distribution of Delay Times by Airport", xlab = '', ylab = "Delay (in Hours)")
#create histograms of the delay times of omega and skybird
hist(omega, main = "Distribution of Delay Times in Omega Airlines", xlab = "Delay (in Hours)")
hist(skybird, main = "Distribution of Delay Times in Skybird Airlines", xlab = "Delay (in Hours)")
#create QQ plots to assess normality in the samples
qqnorm(omega, main = "Normal Q-Q Plot for Delay Times in Omega Airlines")
qqline(omega)
qqnorm(skybird, main = "Normal Q-Q Plot for Delay Times in Skybird Airlines")
qqline(skybird)
#perform a wilcoxon rank sum test to assess if the distributions between omega and skybird are different
wilcox.test(omega,skybird,conf.level = 0.90)
#perform a wilcoxon rank sum test to calculate the confidence interval at the 95% significance level.
wilcox.test(omega,skybird,conf.level = 0.95, conf.int = TRUE)
#import required packages
library(boot)
#create an auxilliary function to caculate the difference in medians.
bootMedianDiff <- function(d,i){
medians = tapply(d[i,1], d[,2], median)
medians[1]-medians[2]
}
#complete the bootstrapping to create a sampling distribution of 2000 median differences using the delay times. Group by airline.
boot.object = boot(delays, bootMedianDiff, R = 2000, strata = delays$airline)
#create a 95% bca confidence interval using the bootstrapped data.
boot.ci(boot.object, conf = 0.95, type = 'bca')
# Don't modify this chunk of code, it is just installing and loading the DS705data package
if (!require(DS705data)){
if (!require(devtools)){
install.packages('devtools',repos="http://cran.rstudio.com")
}
library(devtools)
install_github('DataScienceUWL/DS705data')
}
require(DS705data)
#load in the WormSheep dataset from the DS705data package
data("WormSheep")
#create a boxplot of worms by treatment type.
boxplot(worms~treated, data = WormSheep, main = "Distribution of Worms in Treated vs. Untreated Sheep", xlab = '', ylab = "Number of Worms")
#pull the appropiate data into their own vectors - treated vs. untreated
treated = WormSheep[WormSheep$treated == "treated",1]
untreated = WormSheep[WormSheep$treated == "untreated",1]
#create histograms of the treated and untreated sheep
hist(treated, main = "Distribution of Worms in Treated Sheep", xlab = "Number of Worms")
hist(untreated, main = "Distribution of Worms in Untreated Sheep", xlab = "Number of Worms")
#create QQ plots to assess normality in the samples
qqnorm(treated, main = "Normal Q-Q Plot for Treated Sheep")
qqline(treated)
qqnorm(untreated, main = "Normal Q-Q Plot for Untreated Sheep")
qqline(untreated)
#using the shapiro test to test the normality of the sample for treated sheep.
shapiro.test(treated)
#using the shapiro test to test the normality of the sample for untreated sheep.
shapiro.test(untreated)
#conducting t-test.
t.test(treated,untreated,alternative = "less")
#conducting a t-test for difference in means, testing mu1 - mu2.
t.test(treated,untreated,alternative = "two.sided")
#loading the "delays" dataset from the DS705data package.
data("delays")
#pulling delay times into their own vectors, by airline
omega = delays[delays$airline == "Omega",1]
skybird = delays[delays$airline == "Skybird",1]
#calculating the mean, median and sd for omega
summary(omega)[3:4]
print(paste("Standard Devidation:",sd(omega)))
#calculating the mean, median and sd for skybird
summary(skybird)[3:4]
print(paste("Standard Devidation:",sd(skybird)))
#create a boxplot of delay times by airline.
boxplot(delay~airline, data = delays, main = "Distribution of Delay Times by Airport", xlab = '', ylab = "Delay (in Hours)")
#create histograms of the delay times of omega and skybird
hist(omega, main = "Distribution of Delay Times in Omega Airlines", xlab = "Delay (in Hours)")
hist(skybird, main = "Distribution of Delay Times in Skybird Airlines", xlab = "Delay (in Hours)")
#create QQ plots to assess normality in the samples
qqnorm(omega, main = "Normal Q-Q Plot for Delay Times in Omega Airlines")
qqline(omega)
qqnorm(skybird, main = "Normal Q-Q Plot for Delay Times in Skybird Airlines")
qqline(skybird)
#perform a shapiro test to assess the normality of the omega sample.
shapiro.test(omega)
#perform a shapiro test to assess the normality of the skybird sample.
shapiro.test(skybird)
#perform a wilcoxon rank sum test to assess if the distributions between omega and skybird are different
wilcox.test(omega,skybird,conf.level = 0.90)
#perform a wilcoxon rank sum test to calculate the confidence interval at the 95% significance level.
wilcox.test(omega,skybird,conf.level = 0.95, conf.int = TRUE)
#import required packages
library(boot)
#create an auxilliary function to caculate the difference in medians.
bootMedianDiff <- function(d,i){
medians = tapply(d[i,1], d[,2], median)
medians[1]-medians[2]
}
#complete the bootstrapping to create a sampling distribution of 2000 median differences using the delay times. Group by airline.
boot.object = boot(delays, bootMedianDiff, R = 2000, strata = delays$airline)
#create a 95% bca confidence interval using the bootstrapped data.
boot.ci(boot.object, conf = 0.95, type = 'bca')
